**This note is based on CS61 2018 offering**

Registers
=========
* general-purpose registers
    ```
    64      32      16      8(low)  8(high)
    rax     eax     ax      al      ah      ret val
    rbx     ebx     bx      bl      bh
    rcx     ecx     cx      cl      ch      4th arg
    rdx     edx     dx      dl      ch      3rd arg
    rsi     esi     si      sil     -       2nd arg
    rdi     edi     di      dil     -       1st arg
    r8      r8d     r8w     r8b     -       5th arg
    r9      r9d     r9w     r9b     -       6th arg
    r10, r11, r12, r13, r14, r15
    ```
* special-purpose registers
    ```
    rsp     esp     sp      spl     -       stack pointer
    rbp     ebp     bp      bpl     -       base pointer
    rip     eip     ip      -       -       intr pointer
    rflags  eflags  flags   -       -       flags, condition codes
    ```
## side notes
* registers have no addresses! `*%rax` just mean the content of `%rax`
* register bit width
    * Loading a value into a 32-bit register name sets the upper 32 bits of the 
    register to zero
    * Loading a value into a 16- or 8-bit register name leaves all other bits 
    unchanged.
    * special instr e.g. 
        * `movzbl` moves an 8-bit quantity (a byte) into a 32-bit register (a 
        longword) with zero extension
        * `movslq` moves a 32-bit quantity (longword) into a 64-bit register 
        (quadword) with sign extension
        * no need for `movezlq`

Instructions
============
* Computation
    * perform computation on values, typically values stored in registers
    * (most) have zero/one source operands, one source/destination operand
    * the source operand comes first
    * e.g. `addq %rax, %rbx`: `%rbx := %rbx + %rax`
* Data movement
    * move data between registers and memory
    * (almost all) have one source operand, one destination operand
    * the source operand comes first
* Control flow
    * unconditional branches
    * conditional branches
    * function call
    * return instruction
* Combination
    * `incl (%rax)`: `movl (%rax), %ebx; incl %ebx; movl %ebx, (%rax)`

Directives
==========
* labels
    * `labelname:`, `labelnumber:`
    * markers generated by assembly, used to compute addresses, e.g. 
        * `jmp .L3`
* directives
    * `.directivename arguments`
    * instructions to the assembler e.g. 
        * `.globl L` - label `L` is globally visible in the executable
        * `.long` - puts a number in the output
        * `.text`, `.data` define the current segment
## side notes
* disassembly 
    * assembly that is disassembled from executable instructions
    * GDB, or `objdump -d <obj file>`, or `objdump -S <obj file>`
    * no intermediate labels or directives; they're compiled away
    * compiler generated
        ```asm
            .globl  _Z1fiii
            .type   _Z1fiii, @function
        _Z1fiii:
        .LFB0:
            cmpl    %edx, %esi
            je  .L3
            movl    %esi, %eax
            ret
        .L3:
            movl    %edi, %eax
            ret
        .LFE0:
            .size   _Z1fiii, .-_Z1fiii
        ```
    * disassembly from an object file
        ```
        0000000000000000 <_Z1fiii>:
            0:   39 d6                   cmp    %edx,%esi
            2:   74 03                   je     7 <_Z1fiii+0x7>
            4:   89 f0                   mov    %esi,%eax
            6:   c3                      retq   
            7:   89 f8                   mov    %edi,%eax
            9:   c3                      retq   
        ```
    * disassembly from executable (after linking)
        ```
        0000000000400517 <_Z1fiii>:
            400517:   39 d6                   cmp    %edx,%esi
            400519:   74 03                   je     40051e <_Z1fiii+0x7>
            40051b:   89 f0                   mov    %esi,%eax
            40051d:   c3                      retq   
            40051e:   89 f8                   mov    %edi,%eax
            400520:   c3                      retq 
        ```

Address modes
=============
* normal
    * register
        - `%rbp`
    * immediate
        - `$0x4`
    * memory
        - `0x4`                 value at address 0x4
        - `symbol_name`         value at address of global `symbol_name`
        - `symbol_name(%rip)`   %rip-relative addressing for global
        - `(%rax)`              value at address in `%rax`
        - `0x4(%rax)`           value at address `4 + %rax`
        - `(%rax,%rbx)`         value at address `%rax + %rbx`
        - `(%rax,%rbx,4)`       value at address `%rax + %rbx * 4`
        - `0x18(%rax,%rbx,4)`   value at address `18 + %rax + %rbx * 4`
            - base: `%rax`, offset: `0x18`, index: `%rbx`, scale: `4`
* jumps and function call instructions
    * register
        - `*%rbp`
    * immediate
        - `400410`, or `0x400410`
        - `.L3`
    * memory
        - `*0x200b96(%rip)`
        - `*(%r12,%rbp,8)`
        - and other address modes

## side notes
* `symbol_name`
    * `symbol_name`s are found only in compiler-generated assembly
    * disassembly uses raw addresses (e.g. `0x601030`) or %rip-relateve offsets 
    (e.g. `0x200bf2(%rip)`)
* address computation with `lea`
    * `movl 0x18(%rax,%rbx,4), %ecx` 
    * `leaq 0x18(%rax,%rbx,4), %rcx` 
        * the computed address is moved into register %rcx.
        * this is essentially just computing `%rcx := %rax + 2 * %rbx`
* %rip-relative addressing
    * a global variable named a is referenced as a(%rip) rather than a.
    * supports position-independent code, specifically position-independent 
    executables
    ```
    starting point  instruction     g               delta
    0x400000	    0x400080	    0x401000	    0xF80
    0x404000	    0x404080	    0x405000	    0xF80
    0x4003F0	    0x400470	    0x4013F0	    0xF80
    ```

Calling Convention
==================
## Argument passing and stack frames
* args:
    * first 6  `%rdi, %rsi, %rdx, %rcx, %r8, %r9`
    * 7th and on: stack
* return value: `%rax`
* rule highlights
    * A structure argument that fits in a single machine word (64 bits/8 bytes) 
    is passed in a single register.
    * A structure that fits in two to four machine words (16–32 bytes) is passed
    in sequential registers, as if it were multiple arguments.
    * A structure that’s larger than four machine words is always passed on the 
    stack.
    * Floating point arguments are generally passed in special registers
    * If the return value takes more than eight bytes, then the **caller** 
    reserves space for the return value, and passes the address of that space as
    the first argument of the function. The **callee** will fill in that space 
    when it returns.

## Stack
* `push` 
    * modifies both stack pointer & stack segment
    * `pushq X`: `subq $8, %rsp; movq X, (%rsp)` 
* `pop`
    * `popq X`: `movq (%rsp), X; addq $8, %rsp`
* alignment
    * each stack frame be a multiple of 16 bytes
    * when a callq instruction begins execution, `%rsp` must be 16-byte aligned
    * every function’s entry %rsp address will be 8 bytes off a multiple of 16

## Return address and entry and exit sequence
* entry
    * caller
        1. stores the first six arguments in the corresponding registers
        2. store the surplus arguments (> 6 args, large args) on its stack frame
            * increasing order
            * The 7th argument must be stored at (%rsp) when executing `callq`
        3. saves any caller-saved registers
        4. executes `callq FUNCTION`
            * = `pushq $NEXT_INSTRUCTION; jmp FUNCTION`
            * = `subq $8, %rsp; movq $NEXT_INSTRUCTION, (%rsp); jmp FUNCTION`
* exit
    * callee
        1. places its return value in `%rax`
        2. restores the stack pointer to its value at entry, if necessary
        3. executes `retq`
            * = `popq %rip`
    * caller
        1. cleans up any space it prepared for arguments
        2. restores caller-saved registers if necessary

## Callee-saved registers and caller-saved registers
* Callers can simply use callee-saved registers across function calls; in this 
sense they behave like C++ local variables
* Caller-saved registers behave differently: if a caller wants to preserve the 
value of a caller-saved register across a function call, the caller must 
explicitly save it before the callq and restore it when the function resumes.

## Base pointer
* For simple functions, an optimizing compiler generally treats this like any 
other callee-saved general-purpose register. 
* However, for more complex functions, %rbp is used in a specific pattern that 
facilitates debugging
* entry
    1. `pushq %rbp`
    2. `movq %rsp, %rbp`
* exit
    1. ...
    2. `movq %rbp, %rsp; popq %rbp; retq`
        * = `leave; retq`

## Stack size and red zone
* stack size
    * if a function accesses nonexistent memory near %rsp, the OS assumes it’s 
    for the stack and transparently allocates new memory there 
* red zone
    * small area above the stack pointer (that is, at lower addresses than %rsp) 
    that can be used by the currently-running function for local variables
    * for small functions push and pop instructions end up taking time

Branches
========
* A branch instruction jumps to a new instruction without saving a return 
address on the stack

## unconditional
    * `jmp`, `j`

## conditional
* condition flags
    * branch if come condition holds, represented by condition flags 
    * condition flags are set as a side effect of **every** arithmetic operation
* Arithmetic instructions change part of the %rflags register as a side effect
of their operation.
    - zf: zero flag
    - sf: sign flag, sign bit == 1
    - cf: carry flag, unsigned overflowed
    - of: overflow flag, signed overflowed
* jump
    - j, jump
    - je, jump if equal 0 (check zf)
    - jne, jump if not equal
    - jg, jump if greater
    - jge, jump if greater or equal
    - jl, jump if less
    - jle, jump if less or equal
    - ja, jump if above (unsigned)
    - jae, jump if above or equal (unsigned)
    - jb, jump if below (unsigned)
    - jbe, jump if blow or equal (unsigned)
    - js, jump if sign bit
    - jns, jump if not sign bit
* `test` & `cmp`
    * throw away the result, except for condition codes.
    * `test`: binary-and
        * `testq %rax, %rax`: 
            * load the condition flags appropriately for a single register
            * `testq %rax, %rax; je L`: jumps to L if and only if `%rax` is zero
    * `cmp`: substraction
        * `cmpq %rax, %rbx` evaluates `%rbx - %rax`
        * `cmpq %rax, %rbx; jg L`: jump iff `%rbx` is greater than `%rax`

Questions as we go
==================
* [x] what is this assembly standard? what are the assembly standards? 
    - AT&T & Intel 
* [x] RISC vs CISC
    * RISC - reduced instruction set computer
    * CISC - complex instruction set computer
    * The fundamental difference between the two is that RISC has less number of
    instructions, with each one capable of performing a single operation, while
    CISC has a large number of complex instructions capable of carrying out
    multiple internal operations.
* [x] `addq` targeting register size of the source or the dest? 
    - both; if not provided: dest
* [x] label: what is the value of a symbol? is it the address? 
    - addr
* [-] what are %rflags used for
* [-] directive: `.long`, `.text`, `.data`
* [ ] ldr, str, mov, lea, and more
