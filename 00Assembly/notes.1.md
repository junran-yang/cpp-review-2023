**This note is based on CS61 2018 offering**

Registers
=========
* general-purpose registers
    ```
    64      32      16      8(low)  8(high)
    rax     eax     ax      al      ah      ret val
    rbx     ebx     bx      bl      bh
    rcx     ecx     cx      cl      ch      4th arg
    rdx     edx     dx      dl      ch      3rd arg
    rsi     esi     si      sil     -       2nd arg
    rdi     edi     di      dil     -       1st arg
    r8      r8d     r8w     r8b     -       5th arg
    r9      r9d     r9w     r9b     -       6th arg
    r10, r11, r12, r13, r14, r15
    ```
* special-purpose registers
    ```
    rsp     esp     sp      spl     -       stack pointer
    rbp     ebp     bp      bpl     -       base pointer
    rip     eip     ip      -       -       intr pointer
    rflags  eflags  flags   -       -       flags, condition codes
    ```
## side notes
* registers have no addresses! `*%rax` just mean the content of `%rax`
* register bit width
    * Loading a value into a 32-bit register name sets the upper 32 bits of the 
    register to zero
    * Loading a value into a 16- or 8-bit register name leaves all other bits 
    unchanged.
    * special instr e.g. 
        * `movzbl` moves an 8-bit quantity (a byte) into a 32-bit register (a 
        longword) with zero extension
        * `movslq` moves a 32-bit quantity (longword) into a 64-bit register 
        (quadword) with sign extension
        * no need for `movezlq`

Instructions
============
* Computation
    * perform computation on values, typically values stored in registers
    * (most) have zero/one source operands, one source/destination operand
    * the source operand comes first
    * e.g. `addq %rax, %rbx`: `%rbx := %rbx + %rax`
* Data movement
    * move data between registers and memory
    * (almost all) have one source operand, one destination operand
    * the source operand comes first
* Control flow
    * unconditional branches
    * conditional branches
    * function call
    * return instruction
* Combination
    * `incl (%rax)`: `movl (%rax), %ebx; incl %ebx; movl %ebx, (%rax)`

Directives
==========
* labels
    * `labelname:`, `labelnumber:`
    * markers generated by assembly, used to compute addresses, e.g. 
        * `jmp .L3`
* directives
    * `.directivename arguments`
    * instructions to the assembler e.g. 
        * `.globl L` - label `L` is globally visible in the executable
        * `.long` - puts a number in the output
        * `.text`, `.data` define the current segment
## side notes
* disassembly 
    * assembly that is disassembled from executable instructions
    * GDB, or `objdump -d <obj file>`, or `objdump -S <obj file>`
    * no intermediate labels or directives; they're compiled away
    * compiler generated
        ```asm
            .globl  _Z1fiii
            .type   _Z1fiii, @function
        _Z1fiii:
        .LFB0:
            cmpl    %edx, %esi
            je  .L3
            movl    %esi, %eax
            ret
        .L3:
            movl    %edi, %eax
            ret
        .LFE0:
            .size   _Z1fiii, .-_Z1fiii
        ```
    * disassembly from an object file
        ```
        0000000000000000 <_Z1fiii>:
            0:   39 d6                   cmp    %edx,%esi
            2:   74 03                   je     7 <_Z1fiii+0x7>
            4:   89 f0                   mov    %esi,%eax
            6:   c3                      retq   
            7:   89 f8                   mov    %edi,%eax
            9:   c3                      retq   
        ```
    * disassembly from executable (after linking)
        ```
        0000000000400517 <_Z1fiii>:
            400517:   39 d6                   cmp    %edx,%esi
            400519:   74 03                   je     40051e <_Z1fiii+0x7>
            40051b:   89 f0                   mov    %esi,%eax
            40051d:   c3                      retq   
            40051e:   89 f8                   mov    %edi,%eax
            400520:   c3                      retq 
        ```

Address modes
=============
* normal
    * register
        - `%rbp`
    * immediate
        - `$0x4`
    * memory
        - `0x4`                 value at address 0x4
        - `symbol_name`         value at address of global `symbol_name`
        - `symbol_name(%rip)`   %rip-relative addressing for global
        - `(%rax)`              value at address in `%rax`
        - `0x4(%rax)`           value at address `4 + %rax`
        - `(%rax,%rbx)`         value at address `%rax + %rbx`
        - `(%rax,%rbx,4)`       value at address `%rax + %rbx * 4`
        - `0x18(%rax,%rbx,4)`   value at address `18 + %rax + %rbx * 4`
            - base: `%rax`, offset: `0x18`, index: `%rbx`, scale: `4`
* jumps and function call instructions
    * register
        - `*%rbp`
    * immediate
        - `400410`, or `0x400410`
        - `.L3`
    * memory
        - `*0x200b96(%rip)`
        - `*(%r12,%rbp,8)`
        - and other address modes

## side notes
* `symbol_name`
    * `symbol_name`s are found only in compiler-generated assembly
    * disassembly uses raw addresses (e.g. `0x601030`) or %rip-relateve offsets 
    (e.g. `0x200bf2(%rip)`)
* address computation with `lea`
    * `movl 0x18(%rax,%rbx,4), %ecx` 
    * `leaq 0x18(%rax,%rbx,4), %rcx` 
        * the computed address is moved into register %rcx.
        * this is essentially just computing `%rcx := %rax + 2 * %rbx`
* %rip-relative addressing
    * a global variable named a is referenced as a(%rip) rather than a.
    * supports position-independent code, specifically position-independent 
    executables
    ```
    starting point  instruction     g               delta
    0x400000	    0x400080	    0x401000	    0xF80
    0x404000	    0x404080	    0x405000	    0xF80
    0x4003F0	    0x400470	    0x4013F0	    0xF80
    ```

Questions as we go
==================
* [x] what is this assembly standard? what are the assembly standards? 
    - AT&T & Intel 
* [x] RISC vs CISC
    * RISC - reduced instruction set computer
    * CISC - complex instruction set computer
    * The fundamental difference between the two is that RISC has less number of
    instructions, with each one capable of performing a single operation, while
    CISC has a large number of complex instructions capable of carrying out
    multiple internal operations.
* [x] `addq` targeting register size of the source or the dest? 
    - both; if not provided: dest
* [x] label: what is the value of a symbol? is it the address? 
    - addr
* [-] what are %rflags used for
* [-] directive: `.long`, `.text`, `.data`
* [ ] ldr, str, mov, lea, and more

TIL
===
* register
    * Loading a value into a 32-bit register name sets the upper 32 bits of the 
    register to zero
    * Loading a value into a 16- or 8-bit register name leaves all other bits 
    unchanged.
    * `movzbl` moves an 8-bit quantity (a byte) into a 32-bit register (a 
    longword) with zero extension
    * sign extension (filling with 1's or 0's)
* instr
    * `incl (%rax)`: `movl (%rax), %ebx; incl %ebx; movl %ebx, (%rax)`
    * `leaq 0x18(%rax,%rbx,4), %rcx`: `%rcx := %rax + 2 * %rbx`
* labels
    * used to compute addresses
* directives
    * instructions to the assembler
    * used w/ labels
        ```asm
            .globl  _Z1fiii
            .type   _Z1fiii, @function
        _Z1fiii:
            ...
            .size   _Z1fiii, .-_Z1fiii
        ```
    * `.long`
        ```asm
        g:
            .long 10
        ```
    * `.text`, `.data`

* disassembly 
    * assembly that is disassembled from executable instructions
    * GDB, or `objdump -d <obj file>`, or `objdump -S <obj file>`
    * no intermediate labels or directives; they're compiled away
    * linking changes the address
* position independent executables
    * a security feature
* assembly standard
    * AT&T & Intel 
* RISC vs CISC
    * RISC - reduced instruction set computer
    * CISC - complex instruction set computer
    * The fundamental difference between the two is that RISC has less number of
    instructions, with each one capable of performing a single operation, while
    CISC has a large number of complex instructions capable of carrying out
    multiple internal operations.

Demystification
===============
## Address vs Value
* regular
    * register
        - e.g. `%rax`
    * memory
        - e.g. `0x18(%rax,%rbx,4)`, `4`
        - symbol: 
            - `g`: conventional program
            - `g(%rip)` - position independent executable (PIE)
    * immediate 
        - e.g. `$4`, `$g`
* jump
    * register
        - e.g. `*%rax`
    * memory
        - e.g. `*0x18(%rax,%rbx,4)`, `*4`, `*g`, `*g(%rip)`
    * immediate
        - e.g. `4`, `g`
* side notes
    * think (register, memory) as variables in c++, literals as literals in c++
    * `g` label represents an address
* examples
    * register & literals only
        - `addl %rax, %rbx`   : `%rbx := %rbx + %rax`
        - `addl $1, %rbx`     : `%rbx := %rbx + $1`
    * address & value in memory
        - `movl %rbx, (%rax)` : `(%rax) := %rbx`
        - `movl (%rax), %rbx` : `%rbx := (%rax)`
        - `movl $1, (%rax)`   : `(%rax) := $1`

## Size
* assembly instructions are generally suffixed with the letters "b", "s", "w", 
"l", "q" or "t" to determine what size operand is being manipulated.
* If the suffix is not specified, and there are no memory operands for the 
instruction, GAS infers the operand size from the size of the destination 
register operand (the final operand).
* `movzbl` moves an 8-bit quantity (a byte) into a 32-bit register (a longword) 
with zero extension

* instructions
    * `q, l, w, b`
    * 64 - `addq`
    * 32 - `addl`
    * 16 - `addw`, `adds`
    * 8  - `addb`
    * diff meaning for floating point
* registers, part 1
    * `r, e, -, l/h`
    * 64 - `rax, rbx, rcx, rdx, rsi, rdi`
    * 32 - `eax, ebx, ecx, edx, esi, edi`
    * 16 - `ax, bx, cx, dx, si, di`
    * 8  - `al, bl, cl, dl, sil, dil`
* registers, part 2
    * `-, d, w, b`
    * 64 - `r8, r9`
    * 32 - `r8d, r9d`
    * 16 - `r8w, r9w`
    * 8  - `r8b, r9b`

Take-away
=========
## address & value
* register
    - e.g. `%rax`
* memory
    - e.g. `0x18(%rax,%rbx,4)`, `4`
    - symbol: 
        - `g`: conventional program
        - `g(%rip)` - position independent executable (PIE)
* immediate 
    - e.g. `$4`, `$g`
    - jump: e.g. `4`, `g`

## size
```
64      32      16      8       - bits
q       l       w       b       - instr
%rax    %eax    %ax     %al     - reg
%r8     %r8d    %r8w    %r8b    - reg
```
* `sizeof(bool)` == `sizeof(char)` == 1 byte
* Each address identifies a single byte (eight bits) of storage.